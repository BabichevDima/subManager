// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: subscriptions.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const calculateTotalCost = `-- name: CalculateTotalCost :one
SELECT 
    SUM(price) AS total_cost,
    COUNT(*) AS subscriptions_count
FROM 
    subscriptions
WHERE 
    start_date >= TO_DATE($1, 'MM-YYYY') AND
    start_date <= TO_DATE($2, 'MM-YYYY') AND
    user_id = $3::UUID AND
    service_name = $4 AND
    (end_date IS NULL OR end_date >= CURRENT_DATE)
`

type CalculateTotalCostParams struct {
	StartDate   string
	EndDate     string
	UserId      uuid.UUID
	ServiceName string
}

type CalculateTotalCostRow struct {
	TotalCost          int64
	SubscriptionsCount int64
}

func (q *Queries) CalculateTotalCost(ctx context.Context, arg CalculateTotalCostParams) (CalculateTotalCostRow, error) {
	row := q.db.QueryRowContext(ctx, calculateTotalCost,
		arg.StartDate,
		arg.EndDate,
		arg.UserId,
		arg.ServiceName,
	)
	var i CalculateTotalCostRow
	err := row.Scan(&i.TotalCost, &i.SubscriptionsCount)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (service_name, price, user_id, start_date, end_date)
VALUES (
    $1,
    $2,
    $3,
    TO_DATE($4, 'MM-YYYY'), -- start_date
    CASE 
        WHEN $5 = '' THEN NULL
        ELSE TO_DATE($5, 'MM-YYYY')
    END  
)
RETURNING id, service_name, price, user_id, start_date, end_date, created_at, updated_at
`

type CreateSubscriptionParams struct {
	ServiceName string
	Price       int32
	UserID      uuid.UUID
	ToDate      string
	EndDate     interface{}
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, createSubscription,
		arg.ServiceName,
		arg.Price,
		arg.UserID,
		arg.ToDate,
		arg.EndDate,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ServiceName,
		&i.Price,
		&i.UserID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSubscription = `-- name: DeleteSubscription :execrows
DELETE FROM subscriptions
WHERE id = $1
`

func (q *Queries) DeleteSubscription(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteSubscription, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getSubscription = `-- name: GetSubscription :one
SELECT id, service_name, price, user_id, start_date, end_date, created_at, updated_at FROM subscriptions
WHERE id = $1
`

func (q *Queries) GetSubscription(ctx context.Context, id uuid.UUID) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscription, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ServiceName,
		&i.Price,
		&i.UserID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionByServiceAndUser = `-- name: GetSubscriptionByServiceAndUser :one
SELECT id, service_name, price, user_id, start_date, end_date, created_at, updated_at FROM subscriptions
WHERE service_name = $1
AND user_id = $2
`

type GetSubscriptionByServiceAndUserParams struct {
	ServiceName string
	UserID      uuid.UUID
}

func (q *Queries) GetSubscriptionByServiceAndUser(ctx context.Context, arg GetSubscriptionByServiceAndUserParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionByServiceAndUser, arg.ServiceName, arg.UserID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ServiceName,
		&i.Price,
		&i.UserID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionList = `-- name: GetSubscriptionList :many
SELECT id, service_name, price, user_id, start_date, end_date, created_at, updated_at FROM subscriptions
`

func (q *Queries) GetSubscriptionList(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, getSubscriptionList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscription
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.ServiceName,
			&i.Price,
			&i.UserID,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscription = `-- name: UpdateSubscription :one
UPDATE subscriptions
SET
    service_name = $1,
    price = $2,
    end_date = CASE 
        WHEN $3 = '' THEN NULL
        ELSE TO_DATE($3, 'MM-YYYY')
    END,
    updated_at = NOW()
WHERE id = $4
RETURNING id, service_name, price, user_id, start_date, end_date, created_at, updated_at
`

type UpdateSubscriptionParams struct {
	ServiceName string
	Price       int32
	EndDate     interface{}
	ID          uuid.UUID
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, updateSubscription,
		arg.ServiceName,
		arg.Price,
		arg.EndDate,
		arg.ID,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.ServiceName,
		&i.Price,
		&i.UserID,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
